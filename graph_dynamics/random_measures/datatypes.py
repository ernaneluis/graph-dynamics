'''
Created on Jun 1, 2015

@author: cesar
'''
import copy
import matplotlib
import numpy as np
from scipy.stats import poisson
from collections import namedtuple
from matplotlib import pyplot as plt
from scipy.integrate import quadrature
from abc import ABCMeta, abstractmethod
from graph_dynamics.utils import functions

matplotlib.rcParams['ps.useafm'] = True
matplotlib.rcParams['text.usetex'] = True
matplotlib.rcParams['pdf.use14corefonts'] = True

class CompletlyRandomMeasures(object):
    """
    This class is a superclass for all the completely random measures
    
    the CRM take the following form
    
   
    :math:`W = \sum^{\infty}_{i=1}w_i\delta_{ \\theta_i }`

    :math:`(w_i,\\theta_i)_{i\in \mathbb{N}}` are the points of a Poisson point process on  
    :math: '\mathbb{R}^2_{+}' 
    with mean (or L\'evy measure) $\nu(dw,d\theta) = \rho(dw)\lambda(d\\theta)$. 
    The measure $\rho$ is referred to as the jump part of the L\'evy measure. We denote this process as $W \sim CRM(\rho,\lambda)$
    """
    __metaclass__ = ABCMeta

    def __init__(self,name_string,identifier_string,K):
        self.name_string = name_string
        self.identifier_string = identifier_string
        self.K = K #integer for stick breaking constructions
        
    @abstractmethod
    def jump_measure_intensity(self,t):
        raise NotImplemented()
    
    @abstractmethod
    def lambda_measure_intensity(self,t):
        raise NotImplemented()
    
    @abstractmethod
    def normalized_random_measure(self):
        raise NotImplemented()
    
    @abstractmethod
    def get_measure_state(self):
        raise NotImplemented()
        
class FiniteDimensionalProcess(object):
    """
    Here we follow the paper 
    
    Finite Dimensional BFRY Priors and Variational Bayesian Inference 
    for Power Law Models, to generate measures of the form 
    
    $$
    W = \sum^{K}_{i=1}w_i\delta_{\theta_i}
    $$
    
    We use the notation from Caron, since we expect to use these methods for
    graphs and matrices
    
    
    """
    def __init__(self,name_string,identifier_string,K):
        """
        Constructor of the measure
            name_string: string
                name of the measure
            identifier_string:
                name of the realization of the measure (one such realization is obtained calling )
            K: int 
                number of atoms which approximate the measure
        """
        self.K = K
        self.name_string = name_string
        self.identifier_string = identifier_string
        self.processDefined = False
        
    def GenerateMeasure(self):
        """
        Here we create the measure i.e. we generate the atoms 
        
        $$
        W = \sum^{K}_{i=1}w_i\delta_{\theta_i}
        $$
        
        Returns
        -------
            (self.W,self.Theta)
            
            self.W: list of floats
                    [w_i]
            self.Theta
                    [\theta_i]        
        """
        raise NotImplemented()
    
    def GenerateNormalizedMeasure(self):
        raise NotImplemented
    
    def measure(self,x0,xf):
        """
        Simply returns the number of points generated by the poisson process
        """
        if (x0 >= 0 and xf <= self.interval_size) and (x0 <= xf):
            whereBottom = self.Theta >= x0
            whereTop = self.Theta <= xf
            whereIndex = np.where(whereTop*whereBottom)[0]
            return sum(np.take(self.W,whereIndex))
        else:
            print "Measure evaluated outside definition"
            raise Exception
    
    def PlotProcess(self,plotName="{0}.pdf",saveTo=None,showPlot=False):
        ymin = np.zeros(len(self.W))
        plt.title(self.identifier_string)
        plt.vlines(self.Theta, ymin, self.W)
        plt.plot(self.Theta,self.W,"ro",markersize=12)
        plt.grid(True)
        if showPlot:
            plt.show()
        if saveTo != None:
            plt.savefig(saveTo+plotName.format(self.identifier_string))

    @abstractmethod
    def get_measure_state(self):
        raise NotImplemented()
    
class PoissonMeasure:
    """
    This class defines a measure in the interval $A \in \mathds{R}^{+}$. 
    
    $$
    \Pi = \sum^{\Pi(A)}_{k=1}\delta_{\theta_{k}}
    $$
    
    Which was defined with an intensity function $\lambda(\cdot)$.
    """
    def __init__(self,interval_size=None,measure_state=None,identifier_string="PoissonMeasure",K=None,
                 isLebesque=True,name_string=None,intensity=None,intensity_parameters=None,upper_bound=None):
        """
        THIS CONSTRUCTOR CAN BE INITIALIZED WITH PARAMETERS
        OR DIRECTLY WITH A JSON OBJECT WITH THE FOLLOWING KEYS
        
        measure_state["indentifier_string"] string
        measure_state["interval_size"] float
        measure_state["measure_complete"] float
        measure_state["measure"]["W"] list of floats 
        measure_state["measure"]["Theta"] list of floats
            
        """
        self.name_string = "PoissonMeasure"
        
        #PARAMETERS FOR GENERATION OF ARRIVALS IS REQUIRED
        if measure_state == None:
            self.identifier_string = identifier_string
            self.isLebesque = isLebesque
            self.isDefined = False
        
            #HERE WE DEFINE THE INTENSITIES
            if not isLebesque:
                self.name_string = name_string
                self.intensity = intensity
                self.intensity_parameters = intensity_parameters
                self.interval_size = interval_size
                self.upper_bound = upper_bound
                self.measure_complete = quadrature(self.intensity, 0., self.interval_size, self.intensity_parameters)[0]
            else:
                self.intensity = functions.uniform_one
                self.intensity_parameters = (None,)
                self.interval_size = interval_size
                self.measure_complete = interval_size
                self.upper_bound = 1.
            
            #HERE WE GENERATE THE THETA VALUES (ARRIVALS)
            if K != None:
                self.K = K 
                self.generate_points(K)
            else:
                if self.isLebesque:
                    self.K = int(poisson.rvs(self.measure_complete))
                    self.generate_points(self.K)
                else:
                    #HERE WE SIMPLY USE THE THINNING PROCEDURE
                    J = poisson.rvs(self.interval_size * self.upper_bound)
                    datesInSeconds = np.random.uniform(0., self.interval_size, J)
                    intensities = self.intensity(datesInSeconds, *self.intensity_parameters) / self.upper_bound
                    r = np.random.uniform(0., 1., J)
                    self.Theta = np.take(datesInSeconds, np.where(r < intensities)[0])
                    self.K = len(self.Theta)
                    self.W = np.ones(len(self.Theta))
                    
            self.measure_state = {"Name":self.name_string,
                                  "indentifier_string":self.identifier_string,
                                  "isLebesque":self.isLebesque,
                                  "interval_size":interval_size,
                                  "upper_bound":upper_bound,
                                  "measure_complete":self.measure_complete,
                                  "measure":{"W":self.W.tolist(),"Theta":self.Theta.tolist()}}
            
        #DEFINITION IS GIVEN IN A JSON FILE             
        else:
            #print measure_state
            self.indentifier_string = measure_state["indentifier_string"]
            self.interval_size = measure_state["interval_size"]
            self.measure_complete = measure_state["measure_complete"]
            self.K = len(measure_state["measure"]["Theta"])
            self.W = np.asarray(measure_state["measure"]["W"])
            self.Theta = np.asarray(measure_state["measure"]["Theta"])
            
            # TODO: EVERY JSON RECOVERY FUNCTION SHOULD RECOVER FUNCTIONS AS WELL
            self.isLebesque = True
            self.intensity = functions.uniform_one
            self.intensity_parameters = (None,)
            self.upper_bound = 1.
            self.measure_state = copy.copy(measure_state)
            
    def get_measure_state(self):
        return self.measure_state
                
    def normalized_intensity(self,x):
        """
        normalized version of B0 for the inhomogeneous Poisson Process
        """ 
        return (1./self.measure_complete)*self.intensity(x,*self.intensity_parameters)
    
    def integrate_intensity(self,x0,xf):
        if not self.isLebesque: 
            if (x0 >= 0 and xf < self.interval_size) and (x0 <= xf): 
                return quadrature(self.intensity, x0, xf, self.intensity_parameters)[0]
            else:
                print "Measure evaluated outside definition"
                raise Exception
        else:
            if (x0 >= 0 and xf < self.interval_size) and (x0 <= xf): 
                return xf - x0
            else:
                print "Measure evaluated outside definition"
                raise Exception
            
    def measure(self,x0,xf):
        """
        Simply returns the number of points generated by the poisson process
        """
        if (x0 >= 0 and xf <= self.interval_size) and (x0 <= xf):
            whereBottom = self.Theta >= x0
            whereTop = self.Theta <= xf
            whereIndex = np.where(whereTop*whereBottom)[0]
            return sum(np.take(self.W,whereIndex))
        else:
            print "Measure evaluated outside definition"
            raise Exception
             
    def generate_points(self,K):
        """
        this poisson measure is not properly define if you provide the K by hand
        expects the number of arrivals as defined before hand
        """
        if self.isLebesque:
            self.Theta = np.random.uniform(0,int(self.interval_size),int(K))
            self.W = np.ones(len(self.Theta))
        else:
            Points = []
            while len(Points) < K: 
                rateBound = self.upper_bound/self.measure_complete
                T = self.interval_size
                J = poisson.rvs(T * rateBound)
                datesInSeconds = np.random.uniform(0., T, J)
                intensities = self.normalized_intensity(datesInSeconds) / rateBound
                r = np.random.uniform(0., 1., J)
                arrivals = np.take(datesInSeconds, np.where(r < intensities)[0])
                Points.extend(arrivals)
            self.Theta = np.asarray(Points)[:K]
            self.W = np.ones(len(self.Theta))    
        return self.Theta
    
    def PlotProcess(self,plotName=None,saveTo=None,showPlot=False):
        plt.figure(figsize=(10,3))
        ymin = np.zeros(len(self.W))
        plt.title(self.identifier_string)
        plt.vlines(self.Theta, ymin, self.W)
        plt.plot(self.Theta,self.W,"ro",markersize=12)
        plt.axis([-0.01*self.interval_size,self.interval_size+0.01*self.interval_size,0.,1.1])
        plt.grid(True)
        if showPlot:
            plt.show()
        if saveTo != None:
            plt.savefig(saveTo+plotName)
            
